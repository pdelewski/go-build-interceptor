<h1 id="context">Context</h1>
<p>Whenever we create an abstraction, we should also create tools to
manage it. Abstractions naturally hide some details, and that is fine
when everything works correctly, but it may become a problem when a bug
occurs. They also conceal internal mechanisms, which means it is harder
to understand how something works under the hood. Of course, the people
who design these abstractions have this knowledge, but the people who
use them usually do not—and then they must struggle with unexpected
behavior and differences between the visible model and the actual
execution.</p>
<p>That is why it is so important to provide tools that reduce the
friction introduced by a new, sophisticated abstraction to the bare
minimum and allow users to inspect the hidden details whenever
necessary.</p>
<h1 id="aop-as-an-abstraction">AOP as an Abstraction</h1>
<p>AOP is an interesting abstraction. The idea is to inject additional
functionality into an existing code base in an orthogonal way—similar to
plugging a plugin into the main workflow. Keeping only the primary
business logic in the source code and injecting extra aspects on demand
during compilation seems like a very good idea from the perspective of
comprehension and readability.</p>
<p>There are many cross-cutting concerns—such as logging, tracing, and
instrumentation—that look very attractive for AOP techniques. However,
these methods may introduce subtle problems that are difficult to
notice, debug, and fix without the right tools. At first glance, code
readability appears excellent, but the final program often does not
resemble what you see in the source code. Therefore, it is crucial to
have tools that can display the final effect, help with debugging, and
reveal what has actually been produced.</p>
<h1 id="golang-compilation-process">GoLang Compilation Process</h1>
<p>The Go compiler offers several useful switches that allow us to see
what it is doing and even intercept the compilation process. A few of
them are:</p>
<ul>
<li><code>-a</code> : rebuild the whole project</li>
<li><code>-x</code> : show every compilation step</li>
<li><code>-json</code> : emit the compilation log as structured
JSON</li>
<li><code>-toolexec</code> : allow the injection of a plugin that acts
as an interceptor</li>
</ul>
<p>These switches make it possible to treat the build process itself as
an extensible pipeline.</p>
<h1 id="go-build-interceptor">go-build-interceptor</h1>
<h2 id="hook-compiler-practical-scenario">Hook Compiler — practical
scenario</h2>
<p>go-build-interceptor is a tool composed of two components: the
compiler and the UI. The compiler component injects additional aspects
into the user’s source code during the Go compilation process. The
injection rules are expressed in plain Go in the form of a small
internal DSL, which the tool parses from the file provided as an
argument.</p>
<h3 id="example-project">Example project</h3>
<p>Consider a very simple application in the main package:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> bar2<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> bar1<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    bar2<span class="op">()</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> foo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    bar1<span class="op">()</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">()</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Suppose you would like to execute some extra logic before and after
the foo function, without modifying this original source file. You can
create a separate package — for instance generated_hooks — containing
the following definitions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> generated_hooks</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">(</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;time&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    _ <span class="st">&quot;unsafe&quot;</span> <span class="co">// Required for go:linkname</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;github.com/pdelewski/go-build-interceptor/hooks&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">// ProvideHooks returns the hook definitions for the selected functions.</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> ProvideHooks<span class="op">()</span> <span class="op">[]*</span>hooks<span class="op">.</span>Hook <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">[]*</span>hooks<span class="op">.</span>Hook<span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            Target<span class="op">:</span> hooks<span class="op">.</span>InjectTarget<span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                Package<span class="op">:</span>  <span class="st">&quot;main&quot;</span><span class="op">,</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                Function<span class="op">:</span> <span class="st">&quot;foo&quot;</span><span class="op">,</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                Receiver<span class="op">:</span> <span class="st">&quot;&quot;</span><span class="op">,</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            Hooks<span class="op">:</span> <span class="op">&amp;</span>hooks<span class="op">.</span>InjectFunctions<span class="op">{</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                Before<span class="op">:</span> <span class="st">&quot;BeforeFoo&quot;</span><span class="op">,</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>                After<span class="op">:</span>  <span class="st">&quot;AfterFoo&quot;</span><span class="op">,</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>                From<span class="op">:</span>   <span class="st">&quot;generated_hooks&quot;</span><span class="op">,</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">},</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co">// BeforeFoo is called before foo() executes.</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> BeforeFoo<span class="op">(</span>ctx hooks<span class="op">.</span>HookContext<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    ctx<span class="op">.</span>SetKeyData<span class="op">(</span><span class="st">&quot;startTime&quot;</span><span class="op">,</span> time<span class="op">.</span>Now<span class="op">())</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;[BEFORE] %s.%s()</span><span class="ch">\n</span><span class="st">&quot;</span><span class="op">,</span> ctx<span class="op">.</span>GetPackageName<span class="op">(),</span> ctx<span class="op">.</span>GetFuncName<span class="op">())</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="co">// AfterFoo is called after foo() completes.</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> AfterFoo<span class="op">(</span>ctx hooks<span class="op">.</span>HookContext<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> startTime<span class="op">,</span> ok <span class="op">:=</span> ctx<span class="op">.</span>GetKeyData<span class="op">(</span><span class="st">&quot;startTime&quot;</span><span class="op">).(</span>time<span class="op">.</span>Time<span class="op">);</span> ok <span class="op">{</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        duration <span class="op">:=</span> time<span class="op">.</span>Since<span class="op">(</span>startTime<span class="op">)</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;[AFTER] %s.%s() completed in %v</span><span class="ch">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>            ctx<span class="op">.</span>GetPackageName<span class="op">(),</span> ctx<span class="op">.</span>GetFuncName<span class="op">(),</span> duration<span class="op">)</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When such rules are ready, the interceptor compiler can be executed
using the main switch –compile (or -c for short):</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">go-build-interceptor</span> <span class="at">-c</span> ../../instrumentations/hello/generated_hooks.go</span></code></pre></div>
<p>The tool parses the DSL code, generates trampoline functions inside
the WORK directory, and augments the build plan so that the final
program receives the declared aspects. The original code base remains
untouched and focused solely on business logic.</p>
<h3 id="result">Result</h3>
<p>Running the instrumented binary would produce:</p>
<pre><code>hello
[BEFORE] main.foo()
[AFTER] main.foo() completed in 27.166µs</code></pre>
<p>This practical example shows how AOP-style techniques can stay
transparent and readable as long as proper tooling accompanies the
abstraction.</p>
<h3 id="why-go-dsl-instead-of-yaml">Why Go DSL instead of YAML</h3>
<p>Many projects, including the <a
href="https://github.com/open-telemetry/opentelemetry-go-compile-instrumentation">OpenTelemetry
Go compile-time instrumentation effort</a>, use YAML to express hook
rules. YAML is excellent for basic declarative scenarios, but it becomes
limiting when more sophisticated rewriting logic is required — for
example, changing function signatures, manipulating parameters, or
applying context-sensitive transformations.</p>
<p>For that reason, go-build-interceptor relies on plain Go code as its
DSL. The guiding principle is simple: if you can express a
transformation in Go, you can use it as a rule. YAML can still be
layered on top as a convenience format for trivial cases, but internally
the Go DSL acts as a powerful and flexible representation.</p>
<h2 id="ui">UI</h2>
<p>The second component of go-build-interceptor is the UI, whose main
goal is to reduce the friction related to AOP techniques. It offers a
View menu—a window through which you can examine your project from
different perspectives.</p>
<table>
<tr>
<td align="center" valign="top">
<img src="images/view_menu.jpg" width="180"><br><b>View Menu</b>
</td>
<td align="center" valign="top">
<img src="images/view_functions.jpg" width="180"><br><b>Functions</b>
</td>
<td align="center" valign="top">
<img src="images/view_staticcallgraph.jpg" width="180"><br><b>Call Graph</b>
</td>
<td align="center" valign="top">
<img src="images/view_packages.jpg" width="180"><br><b>Packages</b>
</td>
<td align="center" valign="top">
<img src="images/view_files.jpg" width="180"><br><b>Files</b>
</td>
<td align="center" valign="top">
<img src="images/view_workdirectory.jpg" width="180"><br><b>WORK Dir</b>
</td>
</tr>
</table>
<p>The UI allows users to:</p>
<ul>
<li>generate hook boilerplate automatically using a dedicated
button,</li>
</ul>
<figure>
<img src="images/generatehooks_button.png" alt="Generate Hooks Button" />
<figcaption aria-hidden="true">Generate Hooks Button</figcaption>
</figure>
<ul>
<li>explore the project from a static call-graph view,</li>
<li>browse functions detected in the source code,</li>
<li>inspect files and packages involved in the compilation process.</li>
</ul>
<p>You can also examine the WORK directory, which is a temporary
directory created by the Go compiler to build the project. All
intermediate files are stored there, so you can check exactly how files
modified or added by the interceptor look in their final form.</p>
<p>Last but not least, the UI offers debugging capabilities, where you
can go through the final code step by step, set breakpoints, and verify
that everything behaves as expected.</p>
<figure>
<img src="images/debugging.png" alt="Debugging" />
<figcaption aria-hidden="true">Debugging</figcaption>
</figure>
<p>The UI is independent from the compilation component, so potentially
it could be reused by the OpenTelemetry project or integrated with
existing IDEs in the future.</p>
<h1 id="conclusions">Conclusions</h1>
<p>This project is still in the alpha stage and has several limitations:
missing functionality, shortcuts, and bugs. However, the main goal was
to explore new directions, bring these techniques closer to users, and
provide something that could be used daily as a practical development
tool.</p>
<p>Potentially, the UI could become a plugin (or a set of plugins) for
already existing IDEs, but the objective was to build a tool that is
independent, standalone, and usable without heavy external
dependencies.</p>
<hr />
<p><em><a
href="https://github.com/pdelewski/go-build-interceptor">go-build-interceptor</a>
is open source under the Apache License 2.0. Contributions and feedback
are welcome.</em></p>
